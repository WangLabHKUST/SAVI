#!/bin/bash

### default variables
outputdir=.					# output directory
java_memory=6					# memory of the Java virtual mach in Gigabytes (default: 6)
SGE_TASK_ID=0					# index of region (default: all (0))
myregion=""					# user specified region (default NULL)
mypartition=""					# user specified partition (default NULL)
nopv4=0						# do not compute pv4 (default: no)
noindeldepth=0					# bool which, if on, doesnt include include indel depth in SDP (default: no) (note: asteriks in mpileup are included irrespective of this flag)
rdplusad=0					# bool which, if on, uses RD+AD rather than SDP for total depth (default: no)
hybrid=0					# bool which, if on, uses RD+AD for first sample (normal) and SDP for total depth for all other samples (default: no)
debug=0						# bool to turn on debugging (default: no)
cleanup=1					# bool to turn on cleanup (default: yes)
filter=1					# bool to do SAVI filter (default: yes)
mapq=10						# pileup flag: skip alignments with mapQ less than (default: 10)
minad=2						# pileup2multiallele_vcf flag: min alt depth (AD) to print variant (default: 2)
s1adpp=3					# filter on S1 AD PP less than this - i.e., normal alt depth per position NOT per variant
minallelefreq=4					# for PD.report, Sgt1MAXFREQ is greater than this
stepstr=1245					# what steps to run (default: 1,2,4,5 - don't generate prior)
software=$( dirname $( readlink -m $0 ) )	# directory where to look for scripts
buildprior=${software}/bin/prior_unif01		# input prior for building a new prior (default: bin/prior_unif01)
inputprior=${software}/bin/prior_diploid01	# input prior to use by default (default: bin/prior_unif01)
input_bams=""					# input bam files
input_rna_bams=""				# input rna bam files
sample_names=""					# sample names in a comma-delimited list
num_bams=2					# number of input bams (default: 2)
compsamp="2:1"					# the indices of sample to compare with savi (default: 2:1 - i.e., tumor vs norm)
cutoff=10 					# min read depth cutoff
# anngenome="GRCh37.71"				# annotating reference for SnpEff (if hg19, chrM; if GRCh37.71, chrMT)
anngenome="hg19"
noncoding=0   					# use snpEff to find only all transcripts, not just protein transcripts (default: off)
annvcf=""					# annotating vcfs in comma-delimited list (default: none)
						# common hg19 annotating vcfs in comma-delimited list
savi_present="1e-6"				# the SAVI presence posterior
savi_conf="1e-5"				# the SAVI conf
savi_precision=0				# the SAVI precision, from the Hossein fix
						# required programs
# required_programs="java python samtools snpEff.jar bgzip tabix vcffilter bcftools"
required_programs="java python samtools snpEff.jar bgzip tabix vcffilter bcftools"
required_savi_programs="pileup2multiallele_vcf add_to_info make_qvt savi_poster savi_conf savi_comp savi_poster_accum savi_poster_merge savi_poster_prt savi_unif_prior savi_txt2prior"
helpmessage=$( cat <<EOF
Usage:

$0 --bams [list_of_bam_files] --ref [ref]

Required Arguments:

  --bams		comma-delimited list of bam files (order should be: normal.bam, tumor.bam) (.bai indices should be present)
  --ref			faidx-indexed ref

Options:

  --outputdir		the output directory (default: cwd)
  --region		the genomic region to run SAVI on (default: full range) (example: chr1 or chr1:1-50000000)
			If you use this flag, the index you supply becomes the file suffix.
  --index		the integer index of the region you want to run SAVI on.
			By default, 1 refers to the first chromosome in range.txt, 2 to the second, and so on.
			If you use the partition flag, 1 refers to the first partition, 2 to the second and so on.
			(default: 0, which corresponds to the full range)
  --partition		Number of bases into which to partition the genome.
			Use this flag, only if you want to break your genome into regions smaller than the chr length.
			If you use this flag, you must also specify an index. For example, 
			"--partition 50000000 --index 1" would refer to chr1:1-50000000 for hg19
			(default: not used)
  --names		sample names in a comma-delimited list (must be in the order of your bams) (default: off)
  --compsamp		comma- colon- delimited indices of samples to compare with savi (default: everything compared to sample 1) (example: 2:1,3:1,3:2)
  --steps		steps to run (default: 1,2,4,5 (i.e., all except prior generation))
  --memory		the memory for the Java virtual machine in gigabytes (default: 6)
  --mindepth		the minimum read depth required in at least one sample - positions without this wont appear in pileup file (default: 10)
  --minad		min alt depth (AD) in at least one sample to output variant (default: 2)
  --mapqual		pileup flag: skip alignments with mapQ less than this (default: 10)
  --s1adpp		for filtered report, require the sample 1 (normal) alt depth per position to be less than this (default: 3) (note: this NOT S1 AD per mismatch but, rather, per position)
  --minaf		for PD.report file, Sgt1MAXFREQ is greater than this
  --noclean		do not delete tmp intermediate files (default: off)
  --nopv4		do not run bcftools to compute PV4 (default: off)
  --noindeldepth	do not include include indel reads in total depth count (SDP) (default: off) 
  			(note: asteriks in mpileup are included irrespective of this flag)
  --rdplusad		use reference-agreeing reads plus alternate-calling reads (RD+AD) rather than total depth (SDP) as input to savi (default: off)
  --hybrid		as input to savi, use reference-agreeing reads plus alternate-calling reads (RD+AD) for first sample (normal) and SDP for other samples (default: off)
  			(note: this flag changes read depths on positions where there are multiallelic variants)
  --debug		echo commands (default: off)
  --nofilter		do not use SAVI comparison filter (default: off) (you should use this option if NOT doing comparisons)
  --scripts		location of scripts dir (directory where this script resides - use this option only if qsub-ing)
  --ann-genome		name of the SnpEff genome with which to annotate (default: hg19)
  --noncoding		use snpEff to find all transcripts, not just only protein transcripts (default: off)
  --ann-vcf		comma-delimited list of vcfs with which to provide additional annotation (default: none)
  --buildprior		starting input prior when building the prior (default: bin/prior_unif01)
  --prior		prior to use if step3 is not run (default: bin/prior_diploid01)
  --presence		the SAVI presence posterior (default: 1e-6)
  --conf		the SAVI conf (default: 1e-5)
  --precision		the SAVI precision (default: 0)
  --rnabams		comma-delimited list of rna bam files (.bai indices should be present)
  --help		print this message and exit

Notes:

This scripts assumes that $required_programs are in your PATH.
Your reference should be indexed so a .fai file resides in its directory.
Your bam files should be sorted and indexed so .bai files reside in their directories.

SAVI Steps:

  1 bams to mpileup
  2 mpileup to multiallelic vcf
  3 make prior
  4 run savi
  5 annotate with SnpEff

Variant Calling Protocol:

SAVI is *not* sufficient to get a reliable list of candidate mutations. 
Before you run SAVI, you should follow these steps:

  1 run Fastqc to check the quality of your fastq files
  2 remove low quality sequences and remove adapter contamination with Cutadapt, then re-check quality
  3 map your fastq files with bwa
  4 run Picard to remove PCR duplicates

EOF
)

# If no arguments, echo help message and quit
if [ $# == 0 ]; then
	echo "$helpmessage"
	exit;
fi

### getopts 
while [ $# -gt 0 ]; do
	if [  "$1" == "-h" -o "$1" == "-help" -o "$1" == "--help" ]; then
		shift; 
		echo "$helpmessage"
		exit;
	elif [  "$1" == "-outputdir" -o "$1" == "--outputdir" ]; then
		shift; 
		outputdir=$1; 
		shift
	elif [  "$1" == "-scripts" -o "$1" == "--scripts" ]; then
		shift; 
		software=$1; 
		# update these paths (hack)
		buildprior=${software}/bin/prior_unif01		# input prior for building a new prior
		inputprior=${software}/bin/prior_diploid01	# input prior to use by default
		shift
	elif [  "$1" == "-ref" -o "$1" == "--ref" ]; then
		shift; 
		ref=$( readlink -m $1 ); 
		shift
		if [ ! -e $ref ]; then
			echo "Cannot find the reference file:" 
			echo ${ref}
			exit 1
		fi
	elif [  "$1" == "-vcf" -o "$1" == "--vcf" ]; then
		shift; 
		vcf=$1; 
		shift
	elif [  "$1" == "-names" -o "$1" == "--names" ]; then
		shift; 
		sample_names=$1; 
		shift
	elif [  "$1" == "-compsamp" -o "$1" == "--compsamp" ]; then
		shift; 
		compsamp=$1; 
		shift
	elif [  "$1" == "-steps" -o "$1" == "--steps" ]; then
		shift; 
		stepstr=$1; 
		shift
	elif [  "$1" == "-memory" -o "$1" == "--memory" ]; then
		shift; 
		java_memory=$1;
		shift
	elif [  "$1" == "-mindepth" -o "$1" == "--mindepth" ]; then
		shift; 
		cutoff=$1;
		shift
	elif [  "$1" == "-minad" -o "$1" == "--minad" ]; then
		shift; 
		minad=$1;
		shift
	elif [  "$1" == "-mapqual" -o "$1" == "--mapqual" ]; then
		shift; 
		mapq=$1;
		shift
	elif [  "$1" == "-s1adpp" -o "$1" == "--s1adpp" ]; then
		shift; 
		s1adpp=$1;
		shift
	elif [  "$1" == "-minaf" -o "$1" == "--minaf" ]; then
		shift; 
		minallelefreq=$1;
		shift
	elif [  "$1" == "-ag" -o "$1" == "--ann-genome" ]; then
		shift; 
		anngenome=$1;
		shift
	elif [  "$1" == "-av" -o "$1" == "--ann-vcf" ]; then
		shift; 
		annvcf=$1;
		shift
	elif [  "$1" == "-noncoding" -o "$1" == "--noncoding" ]; then
		shift; 
		noncoding=1; 
	elif [  "$1" == "-noclean" -o "$1" == "--noclean" ]; then
		shift; 
		cleanup=0; 
	elif [  "$1" == "-rdplusad" -o "$1" == "--rdplusad" ]; then
		shift; 
		rdplusad=1;
	elif [  "$1" == "-hybrid" -o "$1" == "--hybrid" ]; then
		shift; 
		hybrid=1;
	elif [  "$1" == "-noindeldepth" -o "$1" == "--noindeldepth" ]; then
		shift; 
		noindeldepth=1;
	elif [  "$1" == "-nopv4" -o "$1" == "--nopv4" ]; then
		shift; 
		nopv4=1;
	elif [  "$1" == "-debug" -o "$1" == "--debug" ]; then
		shift; 
		debug=1; 
	elif [  "$1" == "-nofilter" -o "$1" == "--nofilter" ]; then
		shift; 
		filter=0; 
	elif [  "$1" == "-region" -o "$1" == "--region" ]; then
		shift; 
		myregion=$1; 
		shift
	elif [  "$1" == "-index" -o "$1" == "--index" ]; then
		shift; 
		SGE_TASK_ID=$1; 
		shift
	elif [  "$1" == "-partition" -o "$1" == "--partition" ]; then
		shift; 
		mypartition=$1; 
		shift
	elif [  "$1" == "-buildprior" -o "$1" == "--buildprior" ]; then
		shift; 
		buildprior=$1; 
		shift
	elif [  "$1" == "-prior" -o "$1" == "--prior" ]; then
		shift; 
		inputprior=$1; 
		shift
	elif [  "$1" == "-presence" -o "$1" == "--presence" ]; then
		shift; 
		savi_present=$1; 
		shift
	elif [  "$1" == "-conf" -o "$1" == "--conf" ]; then
		shift; 
		savi_conf=$1; 
		shift
	elif [  "$1" == "-precision" -o "$1" == "--precision" ]; then
		shift; 
		savi_precision=$1; 
		shift
	elif [  "$1" == "-bams" -o "$1" == "--bams" ]; then
		shift; 
		input_bams=$1; 
		# replace commas w spaces
		input_bams=$( echo $input_bams | sed 's|,| |g' ) 
		num_bams=$( echo $input_bams | wc -w )
		shift
	elif [  "$1" == "-rnabams" -o "$1" == "--rnabams" ]; then
		shift; 
		input_rna_bams=$1; 
		# replace commas w spaces
		input_rna_bams=$( echo $input_rna_bams | sed 's|,| |g' ) 
		num_rna_bams=$( echo $input_rna_bams | wc -w )
		shift
	else	# if unknown argument, just shift
		shift
	fi
done

time1=$( date "+%s" )

# update compsamp string if more than 2 samples
if (($num_bams>2)); then 
	compsamp=$( for i in $( seq 2 $num_bams ); do echo -n $i":1,"; done | sed 's|,$||' )
fi

echo "[START] "`date`
echo "[pwd] "`pwd`
echo "[output directory] "$outputdir
echo "[java memory] "$java_memory
echo "[index] "$SGE_TASK_ID
echo "[partition] "$mypartition
echo "[cleanup bool] "$cleanup
echo "[nopv4 bool] "$nopv4
echo "[debug bool] "$debug
echo "[no indel depth bool] "$noindeldepth
echo "[RD+AD bool] "$rdplusad
echo "[hybrid bool] "$hybrid
echo "[filter] "$filter
echo "[mapq qual threshold for samtools mpileup] "$mapq
echo "[minimum alt depth (AD) to print variant] "$minad
echo "[savi steps to run] "$stepstr
echo "[software directory] "$software
echo "[input bams] "$input_bams
echo "[input rna bams] "$input_rna_bams
echo "[input prior for building prior from scratch] "$buildprior
echo "[default input prior] "$inputprior
echo "[sample names] "$sample_names
echo "[number of bams] "$num_bams
echo "[number of rna bams] "$num_rna_bams
echo "[compsamp flag] "$compsamp
echo "[read depth cutoff] "$cutoff
echo "[annotating genome for snpEff] "$anngenome
echo "[annotate noncoding bool] "$noncoding
echo "[annotating list of vcfs] "$annvcf
echo "[savi presence] "$savi_present
echo "[savi precision] "$savi_precision
echo "[dependencies] "$required_programs
echo "[savi proper dependencies] "$required_savi_programs

# check for required programs
for i in $required_programs; do 
	if ! which $i > /dev/null; then
		echo "ERROR: Can't find "${i}". Please add this to your PATH and restart"; 
		exit 1
	fi;
done
for i in $required_savi_programs; do 
	if [ ! -e ${software}/bin/$i ]; then 
		echo -e "ERROR: SAVI/"${i}" not found. Please make sure you've made the binaries:\ncd SAVI/savi\nmake;"; 
		exit 1
	fi; 
done


if [ $( bcftools --version | head -1 | awk '$0 !~ /1.2/{print "true"}' ) ]; then
	echo -e "Must use bcftools v1.2"; 
	exit 1
fi

if [ $( samtools --version | head -1 | awk '$0 !~ /1.2/{print "true"}' ) ]; then
	echo -e "Must use samtools v1.2"; 
	exit 1
fi

if [ $( java -Xmx1G -jar $( which snpEff.jar ) -version | awk '{if ($0 !~ /4.1/) {print "true"}}' ) ]; then
	echo -e "Must use SnpEff v4.1c"; 
	exit 1
fi

# check for bams
for i in $input_bams; do 
	if [ ! -e ${i} ]; then 
		echo "Cannot find the bam file:"
		echo "${i}"
		exit 1
	fi; 
done

# check for reference
if [ ! -e ${ref} ]; then 
	echo "Cannot find the reference file:"
	echo "${ref}"
	exit 1
fi

# check for reference faidx-index 
if [ -e ${ref}.fai ]; then
	echo "[reference] "$ref
else
	echo "This script requires your reference to be faidx-indexed but it cannot find the file:"
	echo "${ref}.fai"
	echo
	echo "Please run:"
	echo "samtools faidx ${ref}"
	exit 1
fi

mkdir -p ${outputdir}

# turn on debugging 
if [ $debug -eq 1 ]; then
	set -eux
fi

# if region set 
if [ ! -z "${myregion}" ]; then

	# if Mitochondria, make special provision
	if [ $myregion == "MT" -o $myregion == "chrMT" ]; then
		anngenome="GRCh37.71"
		echo "[alert] SnpEff annotating genome changed to "${anngenome}
	fi

	if [ ! $( cat ${ref}.fai | awk -v region=${myregion} '$1==region{print "true"}' ) ]; then
		myregion=$( echo $myregion | perl -ne '{ if ($_ =~ m/^chr/) {print substr($_, 3)} else {print "chr".$_ }}' )
		echo "WARNING: region not found. Switched to:"${myregion}
	fi

	regionflag="-r ${myregion}";
	echo "[region] "$myregion
# not set
else
	if [ $SGE_TASK_ID == 0 ]; then
		regionflag="";
		echo "[region] full range"
	else
		# if partition set
		if [ ! -z "${mypartition}" ]; then
			# create a file of ranges, broken by partitions (the fancy perl stuff is just to sort the chrs by number for number-string combos)
			cat ${ref}.fai | perl -ne 'BEGIN{@myarr=()}{chomp($_); @a=split(/\t/, $_); push(@myarr, $a[0]."\t".$a[1])}END{my @sorted = map { $_->[0] } sort { $a->[1] <=> $b->[1] } map { [$_, $_=~/(\d+)/] } @myarr ; foreach $elt (@sorted) {print $elt."\n"}}' | ${software}/bin/partition_genome.pl ${mypartition} > ${outputdir}/range.txt
		else
			# create a file of ranges of chrs (not broken by partitions)
			cat ${ref}.fai | perl -ne 'BEGIN{@myarr=()}{chomp($_); @a=split(/\t/, $_); push(@myarr, $a[0]."\t".$a[1])}END{my @sorted = map { $_->[0] } sort { $a->[1] <=> $b->[1] } map { [$_, $_=~/(\d+)/] } @myarr ; foreach $elt (@sorted) {print $elt."\n"}}' | cut -f1 > ${outputdir}/range.txt
		fi

		echo "[region] "$( cat ${outputdir}/range.txt | head -${SGE_TASK_ID} | tail -1 )
		regionflag="-r "$( cat ${outputdir}/range.txt | head -${SGE_TASK_ID} | tail -1 )

	fi
fi

### need to remove duplicate reads w Picard
# or else get false positives

echo -e "\nStarting Pipeline ...\n"

pileupflag="-A -B -q ${mapq} -d 100000 -L 100000 -f ${ref}"
if [[ $stepstr == *1* ]]; then
	echo "[STEP1] pileup"
	### mpileup

	# if make prior, need to generate all position mpileup (variants and non-variants)
	if [[ $stepstr == *3* ]]; then
		# for mpileup - note the -d flag: "max per-BAM depth to avoid excessive memory usage [250]." The default of 250 is way too low, so we jack it up
		# awk line - we want only lines where normal has depth > cutoff, and at least one of the tumor samples has depth > cutoff
		samtools mpileup ${pileupflag} ${regionflag} ${input_bams} \
	    		| awk -v num=${num_bams} -v cutoff=${cutoff} '{true=0; for (i = 1; i <= num-1; i++) {if ($(4+i*3) >= cutoff) {true=1}}; if (num==1 && $4 >= cutoff) {print} else if (num>1 && $4 >= cutoff && true) {print}}' > ${outputdir}/tmp_mpile.${SGE_TASK_ID}.txt

	# otherwise, just generate variants mpileup
	else
		# for mpileup - note the -d flag: "max per-BAM depth to avoid excessive memory usage [250]." The default of 250 is way too low, so we jack it up
		# awk line - we want only lines where normal has depth > cutoff, and at least one of the tumor samples has depth > cutoff
		# awk line - we also now get only variants (although this will compromise prior generation from scratch) such there's at least $minad of them (roughly - not accounting for indels properly)
		samtools mpileup ${pileupflag} ${regionflag} ${input_bams} | awk -v num=${num_bams} -v cutoff=${cutoff} -v minad=${minad} '
		{
			# reduce pileup by only printing variants

			myflag=0; # flag to print line

			# loop thro samples
			for (i = 1; i <= num-1; i++) 
			{
				# only consider if sample depth greater than or eq to cutoff
				if ($(4+i*3) >= cutoff) 
				{
					# get read string
					mystr=$(5+i*3); 
					# eliminate read starts with qual scores ACTG (e.g., stuff like ^A ^C etc)
					gsub(/\^[ACTGNactgn+-]/,"",mystr); 
					# count ACTGN mismatches
					altdepth = gsub(/[ACTGNactgn]/,"",mystr); 
					# if sufficient number of mismatches, flag line to print
					if (altdepth >= minad) 
					{
						myflag=1; break;
					}
				}
			}

			# if only one sample, print if depth >= cutoff
			if (num==1 && $4 >= cutoff) 
			{
				print;
			}

			# if multiple samples, print if sample one has depth AND myflag
			else if (num>1 && $4 >= cutoff && myflag) 
			{
				print;
			}
		}' > ${outputdir}/tmp_mpile.${SGE_TASK_ID}.txt

	fi

	# if empty
	if [ ! -s ${outputdir}/tmp_mpile.${SGE_TASK_ID}.txt ]; then
		echo "[HALT SCRIPT] pileup file is empty"
		exit 0;
	fi

	echo "[date 1] "`date`;
fi

if [[ $stepstr == *2* ]]; then
	echo "[STEP2] pileup2vcf"
	### Oscan
	# call everything, variants and non-variants alike

	if [ $noindeldepth == 0 ]; then
		# addresses a problem that samtools mpileup does not include indels in the total read count (with the exception of *s)
		# so add indel depths to SDP
		oscanflag="--cutoff ${minad} --header --includeindels";
	else
		# don't include indel reads in total depth count
		oscanflag="--cutoff ${minad} --header";
	fi

	# if make prior, need to generate all position vcf (variants and non-variants)
	if [[ $stepstr == *3* ]]; then
		# add all flag
		oscanflag=${oscanflag}" --all";

		cat ${outputdir}/tmp_mpile.${SGE_TASK_ID}.txt | ${software}/bin/pileup2multiallele_vcf $oscanflag \
		    | tee ${outputdir}/${SGE_TASK_ID}.all.vcf | awk '{ if ($0 ~ /^#/ || toupper($4) != toupper($5)) {print}}' | bgzip > ${outputdir}/${SGE_TASK_ID}.vcf.bgz

		cat ${outputdir}/${SGE_TASK_ID}.all.vcf | bgzip > ${outputdir}/${SGE_TASK_ID}.all.vcf.bgz
		rm ${outputdir}/${SGE_TASK_ID}.all.vcf

		tabix -p vcf ${outputdir}/${SGE_TASK_ID}.all.vcf.bgz

	# otherwise, just generate variants file
	else
		cat ${outputdir}/tmp_mpile.${SGE_TASK_ID}.txt | ${software}/bin/pileup2multiallele_vcf $oscanflag | bgzip > ${outputdir}/${SGE_TASK_ID}.vcf.bgz
	fi

	tabix -p vcf ${outputdir}/${SGE_TASK_ID}.vcf.bgz
	echo "[date 2] "`date`

	# if empty
	if [ $( zcat ${outputdir}/${SGE_TASK_ID}.vcf.bgz | sed '/^#/d' | head | wc -l ) == 0 ]; then
		echo "[HALT SCRIPT] vcf file is empty"
		exit 0;
	fi

	if [ $cleanup -eq 1 ]; then 
		rm -f ${outputdir}/tmp_mpile.${SGE_TASK_ID}.*
	fi

fi

if [[ $stepstr == *3* ]]; then
	echo "[STEP3] make_prior"
	### make_prior.py
	# for samples 1 through n
	#for i in $( seq 1 $num_bams ); do
	# for samples in the compsamp string
	for i in $( echo ${compsamp} | sed 's|,|\n|g; s|:|\n|g' | sort -u ); do
		mkdir -p ${outputdir}/savi/prior${i}
		${software}/make_prior.py --verbose \
		      --name s${i} \
		      --iteration 10 \
		      --prior ${buildprior} \
		      --sampleindex ${i} \
		      --outputdir ${outputdir}/savi/prior${i} \
		      --input ${outputdir}/${SGE_TASK_ID}.all.vcf.bgz;
	done;

	# if run step3, create prior string for priors specified in compsamp
	# if compsamp="2:1", it should look like this - 1:${outputdir}/savi/prior1/prior,2:${outputdir}/savi/prior2/prior
	priorstring=$( for i in $( echo ${compsamp} | sed 's|,|\n|g; s|:|\n|g' | sort -u ); do echo -n "${i}:${outputdir}/savi/prior${i}/prior,"; done | sed 's|,$||'; echo )
	echo "[date 3] "`date`;
else
	# if not step3, use diploid prior by default
	priorstring=$( for i in $( echo ${compsamp} | sed 's|,|\n|g; s|:|\n|g' | sort -u ); do echo -n "${i}:${inputprior},"; done | sed 's|,$||'; echo )
fi

if [[ $stepstr == *4* ]]; then
	echo "[STEP4] run_savi"
	### run_savi.py
	mkdir -p ${outputdir}/savi/out

	if [ $rdplusad == 1 ]; then
		# use AD+RD as tot depth
		saviflag="--rdplusad";
	elif [ $hybrid == 1 ]; then
		# use hybrid mode
		saviflag="--hybrid";
	else
		# use SDP as tot depth
		saviflag="";
	fi

	# invert filter variable
	keepfreqfile=$( echo $filter | awk '{x=$1; print !x}' )

	${software}/run_savi.py $saviflag \
	     --input ${outputdir}/${SGE_TASK_ID}.vcf.bgz \
	     --name savi_${SGE_TASK_ID} \
	     --sample ${compsamp} \
	     --prior ${priorstring} \
	     --saviprecision ${savi_precision} \
	     --savipresent ${savi_present} \
	     --saviconf ${savi_conf} \
	     --keepfreqfile ${keepfreqfile} \
	     --outputdir ${outputdir}/savi/out

	# run_savi.py output files:
	# freqsavi.vcf.bgz - adds presence frequencies to all present variants 
	# finalsavi.vcf.bgz - add frequency deltas for sample comparisons to all present variants 
	# finalfilter.vcf - filter all present mutations for somatic variants

	# if savi comparisons
	if [ $filter -eq 1 ]; then 
		# unzip all present variants
		zcat ${outputdir}/savi/out/finalsavi.vcf.bgz > ${outputdir}/savi/out/finalsavi.vcf
	# if no savi comparisons (e.g., unpaired sample)
	else
		zcat ${outputdir}/savi/out/freqsavi.vcf.bgz > ${outputdir}/savi/out/finalsavi.vcf  
		rm ${outputdir}/savi/out/freqsavi.vcf.bgz ${outputdir}/savi/out/freqsavi.vcf.bgz.tbi
	fi

	# if SAVI vcf empty
	if [ $( cat ${outputdir}/savi/out/finalsavi.vcf | sed '/^#/d' | head | wc -l ) == 0 ]; then
		echo "[HALT SCRIPT] SAVI vcf file is empty"
		exit 0;
	fi

	echo "[date 4] "`date`;
fi

### SnpEff
outputdir2=${outputdir}/ann
if [[ $stepstr == *5* ]]; then
	echo "[STEP5] annotation"
	mkdir -p ${outputdir2}

	# get rid of Ns before annotation because SnpEff messes this up (see bug report: https://github.com/pcingola/SnpEff/issues/54)
	if [ -e ${outputdir}/savi/out/finalsavi.vcf ]; then
		cat ${outputdir}/savi/out/finalsavi.vcf | awk '$0 ~ /^#/ || ($4 !~ /N/ && $5 !~ /N/)' > ${outputdir2}/finalsavi.noN.vcf
	else
		zcat ${outputdir}/savi/out/finalsavi.vcf.bgz | awk '$0 ~ /^#/ || ($4 !~ /N/ && $5 !~ /N/)' > ${outputdir2}/finalsavi.noN.vcf
	fi

	# annotate all present variants, somatic variants
	if [ $noncoding -eq 0 ]; then
		java -Xmx${java_memory}G -jar $( which snpEff.jar ) ann ${anngenome} -noLog -q -c $( which snpEff.config ) -formatEff -noStats -lof -onlyProtein -canon -no-downstream -no-intergenic -no-upstream -no-utr ${outputdir2}/finalsavi.noN.vcf > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_0.all.vcf
	else
		java -Xmx${java_memory}G -jar $( which snpEff.jar ) ann ${anngenome} -noLog -q -c $( which snpEff.config ) -formatEff -noStats -lof -canon ${outputdir2}/finalsavi.noN.vcf > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_0.all.vcf
	fi

	# loop through all annotating vcfs
	myindex=1 						# define index variable for the loop
	num_vcfs=$( echo ${annvcf} | sed 's|,| |g' | wc -w )	# get the total number of annotating vcfs
	for i in $( echo ${annvcf} | sed 's|,| |g' ); do 
		# annotate all present variants
		java -Xmx${java_memory}G -jar $( which SnpSift.jar ) annotate ${i} -noLog ${outputdir2}/tmp_${SGE_TASK_ID}.eff_$(($myindex - 1)).all.vcf > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.all.vcf

		# if cleanup, delete tmp files
		if [ $cleanup -eq 1 ]; then
			rm ${outputdir2}/tmp_${SGE_TASK_ID}.eff_$(($myindex - 1)).all.vcf
		fi

		# if final iteration of loop, convert from vcf to human readable tab-delimited report
		if [ $myindex -eq $num_vcfs ]; then

			cat ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.all.vcf | ${software}/bin/vcf2fullreport.py > ${outputdir2}/report.unfiltered.txt

			# get useful variants and variants in the coding region. The idea is to capture these:
			# inframe_deletion *inframe_insertion frameshift_variant* initiator_codon_variant missense_variant* synonymous_variant*
			# splice_acceptor* splice_donor* splice_region* start_lost* start_gained* stop_gained* stop_lost* stop_retained_variant*
			cat ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.all.vcf | awk -F"\t" '$0 ~ /^#/ || $8 ~ /inframe|frameshift|synonymous_variant|missense_variant|splice_acceptor|splice_donor|splice_region|start|stop/' > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.vcf
			# filtering: 
			# S1 AD PP < cutoff so discard variants with normal alt depth above a certain threshhold
			# discard variants with strand bias
			# discard variants in meganormals
			# discard variants in COMMON dbSNP
			# vcffilter -f "S1ADPP < ${s1adpp} & Sgt1STRANDBIAS = 0" ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.vcf | awk '$0 ~ /^#/ || ( $0 !~ /MEGANORMAL_ID/ && $0 !~ /Meganormal186GBM/ && $0 !~ /COMMON\=1/)' > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.somatic.vcf
			# take out strand bias filter
			vcffilter -f "S1ADPP < ${s1adpp}" ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.vcf | awk '$0 ~ /^#/ || ( $0 !~ /MEGANORMAL_ID/ && $0 !~ /Meganormal186GBM/ && $0 !~ /COMMON\=1/)' > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.somatic.vcf

			# if sample names given, use them
			reportoptions=""
			if [ ! -z $sample_names ]; then 
				reportoptions="--samples $sample_names"
			fi

			# if savi comparisons
			if [ $filter -eq 1 ]; then 
				# make a string for the vcffilter - e.g., if $compsamp is 2:1,3:1,5 then $filterstring will be PD21_L > 0 | PD31_L > 0
				filterstring=$( echo $compsamp | perl -ne '{chomp($line = $_); @myarr = split(/,/, $line); foreach my $elt (@myarr) {if ($elt =~ s/://) {print "PD".$elt."_L > 0 | "}}}' | sed 's|\| $||' )
				# reverse filter
				filterstring_reverse=$( echo $compsamp | perl -ne '{chomp($line = $_); @myarr = split(/,/, $line); foreach my $elt (@myarr) {if ($elt =~ s/://) {print "PD".$elt."_U < 0 | "}}}' | sed 's|\| $||' )

				# if filterstring defined
				if [ ! -z filterstring ]; then 

					# add filter for PD00 if at least 3 samples
					if ((${num_bams}>2)); then 
						filterstring="( Sgt1MAXFREQ > "${minallelefreq}" ) & ( ( P1_L > 0 & P1_L < 51 & P1_U > 49 ) | ( P1_L = 0 ) ) & ( PD00_U < 0 | "${filterstring}" )"; 
						filterstring_reverse="PD00_L > 0 | "${filterstring_reverse}
					else
						filterstring="( P2_F > "${minallelefreq}" ) & ( ( P1_L > 0 & P1_L < 51 & P1_U > 49 ) | ( P1_L = 0 ) ) & ( "${filterstring}" )"; 
						filterstring_reverse="( P1_L > 0 & P1_L < 51 & P1_U > 49 ) & ( "${filterstring_reverse}" )"; 
					fi
				fi

				echo "[filterstring] $filterstring"
				echo "[reverse filterstring] $filterstring_reverse"
				# get somatic variants
				vcffilter -f "${filterstring}" ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.vcf > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.PDfilter.vcf
				vcffilter -f "${filterstring_reverse}" ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.vcf > ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.rev-PDfilter.vcf

				cat ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.PDfilter.vcf | ${software}/bin/vcf2newreport_for_v4.1.C.py ${reportoptions} | sed 's|,|, |g' > ${outputdir2}/report.coding.PDfilter.txt
				cat ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.rev-PDfilter.vcf | ${software}/bin/vcf2newreport_for_v4.1.C.py ${reportoptions} | sed 's|,|, |g' > ${outputdir2}/report.coding.rev-PDfilter.txt

				# ugly hack to get PV4, if report nonzero size
				if [ -s ${outputdir2}/report.coding.PDfilter.txt -a $nopv4 -eq 0 ]; then 

					if (( $( cat ${outputdir2}/report.coding.PDfilter.txt | sed '1d' | wc -l ) > 5000 )); then 
						echo "WARNING: report too long to run bcftools per variant"; 
					else

						echo -e "#chromosome:position_ref/alt\tbcftools_qual\tvariant_distance_bias\tmap_qual_0_fraction\tPV4_strand_bias\tPV4_baseQ_bias\tPV4_mapQ_bias\tPV4_tail_distance_bias" > ${outputdir2}/tmp.txt
						# The point of this awk + tableconcatlines is to join on the common variants and unify the reported indel format (we do it differently than bcftools)

						# make sure this doesn't exist
						rm -f ${outputdir2}/tmp.rna.vcf

						cat ${outputdir2}/report.coding.PDfilter.txt | sed '1d' | cut -f1,2,3,4 | while read mychr mypos myref myalt; do 
							samtools mpileup -g -A -B -q 0 -d 100000 -L 100000 -f ${ref} ${input_bams} -r ${mychr}:${mypos}-${mypos} 2> /dev/null \
									| bcftools call -p 1.1 -A -c - 2> /dev/null \
									| awk -v ref=${myref} -v alt="${myalt}" -v pos="${mypos}" -v chr=${mychr} '$0 !~ /^#/{ mytmp4=$4; mytmp5=$5; sub(ref,"",mytmp4); sub(alt,"",mytmp5); if (ref != $4 && mytmp4 != mytmp5 || alt != $5 && mytmp4 != mytmp5) { print chr":"pos"_"$4"/"$5"\t-\t-\t-\t-\t-\t-\t-" } else { printf chr":"pos"_"ref"/"alt"\t"$6; split($8,a,";"); flag=0; for (i = 1; i <= length(a); i++) { if (a[i] ~ /VDB|MQ0F/ ) { split(a[i],b,"="); flag+=1;  if (a[i] ~ /MQ0F/ && flag==1) { flag+=1; printf "\t-\t"b[2]} else {printf "\t"b[2]} } else if (a[i] ~ /PV4/ && flag == 1) { split(substr(a[i],5),b,","); flag=6; print "\t-\t"b[1]"\t"b[2]"\t"b[3]"\t"b[4] } else if (a[i] ~ /PV4/ && flag == 0) { split(substr(a[i],5),b,","); flag=6; print "\t-\t-\t"b[1]"\t"b[2]"\t"b[3]"\t"b[4] } else if (a[i] ~ /PV4/ && flag == 2) { split(substr(a[i],5),b,","); flag=6; print "\t"b[1]"\t"b[2]"\t"b[3]"\t"b[4] } }; for (i=1; i<=6-flag; i++) { if (i==6-flag) { print "\t-" } else { printf "\t-" } }  } }'; done >> ${outputdir2}/tmp.txt
						## bug when pv4 missed#	| awk -v ref=${myref} -v alt=${myalt} -v pos=${mypos} -v chr=${mychr} '$0 !~ /^#/{ mytmp4=$4; mytmp5=$5; sub(ref,"",mytmp4); sub(alt,"",mytmp5); if (ref != $4 && mytmp4 != mytmp5 || alt != $5 && mytmp4 != mytmp5) { print chr":"pos"_"ref"/"alt"\t-\t-\t-\t-\t-\t-\t-" } else { printf chr":"pos"_"ref"/"alt"\t"$6; split($8,a,";"); for (i = 1; i <= length(a); i++) { if (a[i] ~ /VDB|MQ0F/ ) { split(a[i],b,"="); printf "\t"b[2] } else if (a[i] ~ /PV4/ ) { split(substr(a[i],5),b,","); print "\t"b[1]"\t"b[2]"\t"b[3]"\t"b[4] } } } }'; done >> ${outputdir2}/tmp.txt
						## bug when two lines with same ID

						cat ${outputdir2}/report.coding.PDfilter.txt | awk -F"\t" '{print $1":"$2"_"$3"/"$4"\t"$0}' > ${outputdir2}/tmp.tmp.txt
						ncols=$(cat ${outputdir2}/report.coding.PDfilter.txt | head -1 | awk -F"\t" '{print NF}')
						${software}/bin/tableconcatlines ${outputdir2}/tmp.tmp.txt ${outputdir2}/tmp.txt | cut -f2- | awk -F"\t" -v n=$ncols '{if(NF==n+1){print $0"-\t-\t-\t-\t-\t-\t-"}else{print}}' > ${outputdir2}/report.coding.PDfilter.pv4.txt

						# if rna bam files
						if [ ! -z "$input_rna_bams" ]; then 
							input_rna_bams_nodash=$( echo $input_rna_bams | sed 's| - | |g' )
							cat ${outputdir2}/report.coding.PDfilter.txt | sed '1d' | cut -f1,2,3,4 | while read mychr mypos myref myalt; do 
								samtools mpileup -A -B -q 0 -d 100000 -L 100000 -f ${ref} ${input_rna_bams_nodash} -r ${mychr}:${mypos}-${mypos} 2> /dev/null \
									| ${software}/bin/pileup2multiallele_vcf --includeindels | sed '/^#/d'

							done >> ${outputdir2}/tmp.rna.vcf
						fi
						
						# if rna bam files
						if [ ! -z "$input_rna_bams" ]; then 

							cat ${outputdir2}/tmp.rna.vcf | awk 'BEGIN{print "#chromosome:position_ref/alt"}{print $1":"$2"_"$4"/"$5}' > ${outputdir2}/tmp.key.txt

							for j in $( seq 1 $num_rna_bams ); do 

								z=$( echo "${rna_bams}" | cut -d' ' -f${j} )

								if [  "$z" == "-" ]; then
									echo "X" | awk -v sampnum=$j '{print "rna_samp_"sampnum"_tot_depth\trna_samp_"sampnum"_alt_depth"; print "-\t-"}' > ${outputdir2}/tmp.pasteme.${j}.txt; 
								else
									cat ${outputdir2}/tmp.rna.vcf | ${software}/bin/make_qvt -s $j | cut -f2- > ${outputdir2}/tmp.deleteme.txt

									if [ -s ${outputdir2}/tmp.deleteme.txt ]; then 
										cat ${outputdir2}/tmp.deleteme.txt | awk -v sampnum=$j 'BEGIN{print "rna_samp_"sampnum"_tot_depth\trna_samp_"sampnum"_alt_depth"}{print $2"\t"$1}' > ${outputdir2}/tmp.pasteme.${j}.txt; 
									else
										echo "X" | awk -v sampnum=$j '{print "rna_samp_"sampnum"_tot_depth\trna_samp_"sampnum"_alt_depth"; print "0\t0"}' > ${outputdir2}/tmp.pasteme.${j}.txt; 
									fi
								fi

							done

							paste ${outputdir2}/tmp.key.txt ${outputdir2}/tmp.pasteme.*.txt > ${outputdir2}/tmp.rna.res.txt
							cat ${outputdir2}/report.coding.PDfilter.pv4.txt | awk -F"\t" '{print $1":"$2"_"$3"/"$4"\t"$0}' > ${outputdir2}/tmp.tmp.tmp.txt
							# ${software}/bin/tableconcatlines ${outputdir2}/tmp.tmp.txt ${outputdir2}/tmp.rna.res.txt | cut -f2- > ${outputdir2}/report.coding.PDfilter.pv4.rna.txt
							${software}/bin/tableconcatlines ${outputdir2}/tmp.tmp.tmp.txt ${outputdir2}/tmp.rna.res.txt | cut -f2- | awk -F"\t" -v bams="${input_rna_bams}" 'BEGIN{fill=""; split(bams,a," "); for (i in a) {if (a[i]=="-") {x=x"-\t-\t"} else {x=x"0\t0\t"}}}{if (NR==1) {numfields=NF}; if (NF==numfields) {print} else {print $0 x}}' > ${outputdir2}/report.coding.PDfilter.pv4.rna.txt

						fi

						if [ $cleanup -eq 1 ]; then 
							rm ${outputdir2}/tmp.key.txt ${outputdir2}/tmp.pasteme.*.txt ${outputdir2}/tmp.rna.res.txt ${outputdir2}/tmp.rna.vcf
							rm  ${outputdir2}/tmp.tmp.txt ${outputdir2}/tmp.tmp.tmp.txt ${outputdir2}/tmp.txt ${outputdir2}/tmp.deleteme.txt
						fi


					fi
				fi
			fi

			# turn vcf into human readable, tab delimited report
			cat ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.vcf | ${software}/bin/vcf2newreport_for_v4.1.C.py ${reportoptions} | sed 's|,|, |g' > ${outputdir2}/report.coding.txt
			cat ${outputdir2}/tmp_${SGE_TASK_ID}.eff_${myindex}.coding.somatic.vcf | ${software}/bin/vcf2newreport_for_v4.1.C.py ${reportoptions} | sed 's|,|, |g' > ${outputdir2}/report.coding.somatic.txt

		fi

		myindex=$(($myindex + 1))

	done

	echo "[date 5] "`date`;
fi

echo "[STEP CLEANUP] clean up"
# if cleanup
if [ $cleanup -eq 1 ]; then 
	rm -f ${outputdir}/${SGE_TASK_ID}.all.vcf.bgz*
	rm -f ${outputdir}/${SGE_TASK_ID}.vcf.bgz*
	rm -f ${outputdir}/savi/out/freqsavi.vcf.bgz*
	# remove this because we already have the zipped version
	rm -f ${outputdir}/savi/out/finalsavi.vcf
fi

time2=$( date "+%s" )
echo "[deltat] "$(( $time2 - $time1 ))
echo "[END] "`date`
